<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<!-- saved from url=(0052)http://bdis.umeta.ru/db//db_course/labs/ref/app9.htm -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">

   
  <title>Индексы</title>
</head>

<body>
<p>
</p><table cellpadding="10">
<tbody><tr><td><a href="http://bdis.umeta.ru/db//db_course/labs/index.htm">Индекс раздела</a></td><td><a href="http://bdis.umeta.ru/db//db_course/labs/ref/app8.htm">Назад</a></td><td><a href="http://bdis.umeta.ru/db//db_course/labs/ref/index.htm">Оглавление</a></td><td><font color="#C0C0C0">Вперед</font></td></tr>
</tbody></table>
<hr>
<h3 align="center">Использование индексов.</h3>

<a name="1">
<h4>1. Основные принципы построения индексов.</h4>

<p>Рассмотрим пример того, как индексы могут использоваться для ускорения выборки данных. На рис. 1 показанв таблица "Состав школы", содержащая имена и занимаемые должности всех работников школы:

</p><p></p><table align="center">
<tbody><tr><td align="center">
<img src="./Индексы_files/indexSchoolStart.jpg"></td>
</tr><tr><td align="center">
Рис.1. Таблица "Состав школы"
</td></tr></tbody></table>

<p>Как поступить, если из этой таблицы необходимо выбрать имена всех работников, занимающих должность техника? Можно прочитать все строки данных таблицы и отобразить имена только тех работников, которые занимают должность техника. Процедура последовательного считывания всех строк таблицы в целях выполнения запроса называется <b><i>сканированием таблицы</i></b>. А теперь создадим индекс для столбца "Должность" таблицы "Состав щколы", или, другими словами, проиндексируем эту таблицу по столбцу "Должность". Результаты этой работы представлены на рис. 2:

</p><p></p><table align="center">
<tbody><tr><td align="center">
<img src="./Индексы_files/indexSchoolIndex.jpg"></td>
</tr><tr><td align="center">
Рис.2. Индекс по столбцу "Должность" таблицы "Состав щколы"
</td></tr></tbody></table>

<p>Показанный на рис. 2 индекс содержит указатель на данные. Воспользуемся этим индексом для выполнения того же запроса. Вместо полного сканирования таблицы "Состав щколы" считывается только первая строка индекса и проверяется должность. Если это не интересующее нас значение "Техник", считывается следующая строка, и так, пока не будет найдена первая строка с требуемым значением. Из найденной строки выбирается указатель на запись, представляющий собой точный последовательный номер соответствующей строки таблицы "Состав щколы". Чтение строк индекса продолжается до тех пор, пока в его строках будет содержаться требуемое значение "Техник", после чего обработка индекса прекращается.

</p><p>Для понимания того, как подобный алгоритм поиска нужной строки помогает ускорить выполнение запроса, кратко рассмотрим физическую структуру хранимых данных MSSQL. В MSSQL данные и индексы таблиц хранятся в виде страниц, формат которых показан на рис. 3:

</p><p></p><table align="center">
<tbody><tr><td align="center">
<img src="./Индексы_files/indexPageFormat.jpg"></td>
</tr><tr><td align="center">
Рис.3. Формат страницы данных SQL Server
</td></tr></tbody></table>

<p>Каждая страница размером 8192 байт включает заголовок, имеющий длину 96 байт. Еще один фрагмент страницы используется для размещения других структур данных, например, информации о переполнении строк. Вся оставшаяся часть страницы (8060 байт) предназначена для размещения данных (т.е. информации таблицы или индекса).

</p><p>Предположим, что таблица "Состав щколы" содержит и другую информацию, например домашний адрес работника, номер телефона и т.д. Размер одной строки данных таблицы "Состав щколы" в этом случае может составлять приблизительно 2000 байт, тогда как ширина столбца "Должность" составляет 25 байт. Учитывая приведенные значения, разместим показанную на рис. 1 таблицу и показанный на рис. 2 индекс на страницах SQL Server, формат которых представлен на рис. 3. Данное размещение показано на рис. 4:

</p><p></p><table align="center">
<tbody><tr><td align="center">
<img src="./Индексы_files/indexSchoolStructure.jpg"></td>
</tr><tr><td align="center">
Рис.4. Страницы данных таблицы "Состав школы" и ее индекса в базе данных SQL Server 
</td></tr></tbody></table>

<p>Исходя из представленной на рис. 4 схемы рассмотрим, как в SQL Server будет выполняться поиск (без использования индекса) всех работников школы, занимающих должность "Заместитель директора". Прежде всего, будет считана страница с номером пять и ее данные будут просмотрены в поисках записей о нужных работниках. На первой странице (номер пять) такие записи найдены не будут. SQL Server считает следующую страницу (номер десять), просмотрит ее содержимое и выведет информацию из четвертой записи. Поскольку системе неизвестно, в скольких записях столбца "Должность" таблицы содержится значение "Заместитель директора", будет считана и просмотрена еще одна , последняя, страница таблицы с номером двенадцать. Итак, SQL Server выполнил полное сканирование таблицы, прочитав все записи с ее данными - в этом примере считывается всего три страницы данных. Ну, а если бы таблица "Состав школы" содержала бы в тысячу раз больше записей - около 9000 (что совсем не много для SQL Server)? Тогда для выборки необходимых данных пришлось бы считать 3000 страниц, причем даже в том случае, если бы в ней существовала только одна удовлетворяющая условию запись.

</p><p>Рассмотрим, как будет выполняться тот же запрос с использованием индекса. Прежде всего, SQL Server считает страницу с данными индекса и промотрит ее содержимое в поисках значения "Заместитель директора". Искомое значение содержится в третьей строке. Из этой строки выбирается значение указателя, показывающее, что соответствующая запись является четвертой на странице номер десять. SQL Server считывает десятую страницу, выбирает четвертую строку и отображает найденное значение имени. Номер строки на странице сокращенно обозначается RID (Row Identifier). Затем проверяется значение в следующей строке индекса. Поскольку значение в ней отличается от искомого, SQL Server заканчивает обработку запроса. Таким образом, в данном случае для выполнения запроса потребовалось считать только две страницы, а не три, как в случае сканирования таблицы.

</p></a><p><a name="1">А что можно сказать о выполнении обсуждавшегося выше запроса об именах техников? Сканирование таблицы предусматривает чтение всех трех страниц данных. Использование же индекса потребует от SQL Server считать все три страницы данных, плюс еще одну страницу индекса. В итоге считанных страниц получится даже больше, чем при обычном сканировании! В некоторых случаях сканирование таблицы может оказаться эффективнее по сравнению с примененим для поиска индекса. Принятие решения о выборе используемого при поиске индекса или применении метода сканирования в SQL Server возлагается на службу оптимимзации запросов.

</a><a name="2">
</a></p><h4><a name="2">2. Структура индексов в Microsoft SQL Server.</a></h4><a name="2">

<p>Для представления индексов в SQL Server используется схема двоичного дерева, показанная на рис. 5. Двоичные деревья представляют собой многоуровневые динамические поддерживаемые структуры.

</p><p></p><table align="center">
<tbody><tr><td align="center">
<img src="./Индексы_files/indexBinaryTree.jpg"></td>
</tr><tr><td align="center">
Рис.5. Схема построения двоичного дерева
</td></tr></tbody></table>

<p>Двоичное дерево состоит из верхнего уровня, называемого <b><i>корнем</i></b>, нижнего уровня, называемого <b><i>листами</i></b> (это всегда уровень 0), и несколько (от 0 до N) <b><i>промежуточных уровней</i></b>. Дерево на рис. 5 включает один промежуточный уровень. В терминах SQL Server каждый из прямоугольников на рис. 5 отображает страницу индекса (или страницу данных). Чем больше уровней используется для представления индекса, тем больше страниц индекса потребуется считать для получения доступа к искомым записям данных (т.е с увеличением числа уровней производительность обработки индекса уменьшается). В SQL Server поддерживается два различных типа индексов - <b><i>кластерные</i></b> и <b><i>некластерные</i></b>.

</p><h5>2.1. Кластерный индекс.</h5>

<p><b><i>Кластерный индекс</i></b> представляет собой двоичное дерево, в котором на нулевом уровне (уровне листов) содержатся страницы актуальных данных таблицы, а физически информация хранится в логическом порядке данного индекса.

</p><p>При создании кластерного индекса резко возрастает количество дисковых операций ввода-вывода, связанное с переупорядочиванием страниц данных, созданием страниц индекса и удалением освободившихся страниц данных таблицы.

</p><p>На рис. 6 показан пример кластерного индекса, созданного для столбца "Имя" таблицы "Состав школы". Обратите внимание, что страницы данных являются листовыми страницами этого кластерного индекса, а информация на страницах данных логически упорядочена.

</p><p></p><table align="center">
<tbody><tr><td align="center">
<img src="./Индексы_files/indexClaster.jpg"></td>
</tr><tr><td align="center">
Рис.6. Кластерный индекс для столбца "Имя" таблицы "Состав школы"
</td></tr></tbody></table>

<p>Поскольку записи на страницах данных физически располагаются в требуемом порядке, для каждой таблицы может существовать только один кластерный индекс.

</p><p>В SQL Server страницы индексов состоят из заголовка страницы, после которого располагаются собственно строки индекса. Строки индекса состоят из ключевого значения и указателя на страницу индекса или строку данных таблицы (листовой уровень кластерного индекса). Страницы индекса последовательно связываются друг с другом с помощью двунаправленных ссылок.

</p><h5>2.2. Некластерные индексы.</h5>

<p>В случае <b><i>некластерных индексов</i></b> страницы листового уровня содержат не актуальные данные таблицы (как в случае кластерного индекса), а указатель на строку данных, включающий номер страницы данных и порядковый номер записи на странице. Некластерный индекс не требует физического переупорядочивания строк данных таблицы.

</p><p>На рис. 7 показан пример некластерного индекса для столбца "Имя" таблицы "Состав школы":

</p><p></p><table align="center">
<tbody><tr><td align="center">
<img src="./Индексы_files/indexNonClaster.jpg"></td>
</tr><tr><td align="center">
Рис.7. Некластерный индекс для столбца "Имя" таблицы "Состав школы"
</td></tr></tbody></table>

</a><p><a name="2">Обратите внимание, что некластерные индексы всегда имеют на один уровень больше кластерных, поэтому после достижения уровня листов дополнительно потребуется выполнить чтение страницы данных. Если таблица имеет кластерный индекс, указатели строк некластерных индексов будут ссылаться на уровень листов кластерного индекса. Если таблица не имеет кластерного индекса, указатель строк представляет собой RID, создаваемый на основе идентификатора файла, номера страницы и номера записи на странице.

</a><a name="3">
</a></p><h4><a name="3">3. Рекомендуемая стратегия использования индексов.</a></h4><a name="3">

<p>Выбор используемых индексов определяется структурой таблиц и типом запросов, с помощью которых будет выполняться поиск данных в этих таблицах . Прежде счем приступать к созданию индексов, надо убедиться, что индексируемые столбцы входят в критерии поиска запросов или помещаются в таблицы по каким-либо другим соображениям, например для предотвращения дублирования данных. В последующих разделах обсуждаются некоторые аспекты стратегии использования индексов.

</p><h5>3.1. Что следует индексировать.</h5>

<p>Ниже приведено несколько критериев, которыми можно руководствоваться при определении, какие именно столбцы таблицы следует индексировать:
</p><ul>
<li>Столбцы, используемые для объединения таблиц
</li><li>Столбцы, используемые для ограничения диапазона данных, которые анализируются при выполнении запросов
</li><li>Столбцы, используемые в директивах <samp>ORDER BY</samp> и <samp>GROUP BY</samp> запросов
</li><li>Столбцы, используемые в функциях суммирования и подведения итогов
</li></ul>

<h5>3.2. Что не следует индексировать.</h5>

<p>Ниже приведены случаи, когда индексацию не следует использовать вовсе или использовать в крайне ограниченных масштабах:
</p><ul>
<li>Таблицы содержат незначительное количество строк
</li><li>Столбцы имеют слабо выраженную селективность (т.е. очень широкий диапазон значений)
</li><li>Значения в столбцах имеют очень большую длину (не рекомендуется индексировать столбцы с значениями длиннее 25 байт)
</li><li>Столбцы при построении запросов не используются
</li></ul>

<h5>3.3. Кластерные и некластерные индексы.</h5>

<p>Как уже упоминалось, для каждой таблицы может существовать только один кластерный индекс. Ниже перечислены случаи, в которых применять кластерные индексы целесообразно:
</p><ul>
<li>Столбцы используются в широком диапазоне запросов
</li><li>Столбцы используются в директивах <samp>ORDER BY</samp> и <samp>GROUP BY</samp> запросов
</li><li>Столбцы используются для объединения таблиц
</li><li>Используются запросы, возвращающие большой результирующий набор данных
</li></ul>

<p>Некластерные индексы целесообразно применять в ситуациях, перечисленных ниже:
</p><ul>
<li>Столбцы используются в функциях суммирования и группирования
</li><li>Столбцы имеют внешние ключи
</li><li>Используются запросы, возвращающие небольшие результирующие наборы данных
</li><li>Доступ к информации часто осуществляется с помощью некоторого столбца, используемого в условиях объединения таблиц или в директивах <samp>ORDER BY</samp> и <samp>GROUP BY</samp> запросов
</li></ul>

<p></p><hr>
<table cellpadding="10">
<tbody><tr><td><a href="http://bdis.umeta.ru/db//db_course/labs/index.htm">Индекс раздела</a></td><td><a href="http://bdis.umeta.ru/db//db_course/labs/ref/app8.htm">Назад</a></td><td><a href="http://bdis.umeta.ru/db//db_course/labs/ref/index.htm">Оглавление</a></td><td><font color="#C0C0C0">Вперед</font></td></tr>
</tbody></table>


</a></body></html>